<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>NUCC Progression Map</title>
  <script src="https://unpkg.com/vis-network@9.1.6/dist/vis-network.min.js"></script>
  <link href="https://unpkg.com/vis-network@9.1.6/dist/vis-network.min.css" rel="stylesheet" />
  <style>
  :root {
    color-scheme: dark;
  }

  body {
    margin: 0;
    background-color: #000;
    color: #f0f0f0;
    font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
  }

  /* --- Base layout (desktop & landscape default) --- */
  #split-container {
    display: flex;
    flex-direction: row;
    height: 100vh;
    width: 100%;
    background: #000;
  }

  #graph-div {
    flex: 2;
    border-right: 1px solid rgba(255, 255, 255, 0.2);
    overflow: hidden;
    position: relative;
    isolation: isolate;
    background: #000;
    color: #fff;
  }

  #graph-div::before {
    content: "";
    position: absolute;
    inset: 0;
    background-image: url("background.png");
    background-size: cover;
    background-position: center;
    background-attachment: fixed;
    z-index: 0;
    transform: scale(1.02);
  }

  #graph-div::after {
    content: "";
    position: absolute;
    inset: 0;
    background: linear-gradient(90deg, rgba(0,0,0,0.5) 0%, rgba(0,0,0,0.65) 50%, rgba(0,0,0,0.75) 100%);
    z-index: 1;
  }

  #graph-div > * {
    position: relative;
    z-index: 2;
  }

  #graph-hotspots {
    position: absolute;
    inset: 0;
    display: flex;
    justify-content: center;
    align-items: stretch;
    pointer-events: none;
    z-index: 3;
  }

  .hotspot-column {
    flex: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: clamp(10px, 4vw, 40px) 0;
  }

  .icon-button {
    pointer-events: auto;
    width: clamp(54px, 12vw, 90px);
    aspect-ratio: 1;
    border-radius: 50%;
    border: 2px solid rgba(255, 255, 255, 0.35);
    background: transparent;
    box-shadow: 0 0 18px rgba(0, 0, 0, 0.45);
    display: inline-flex;
    align-items: center;
    justify-content: center;
    transition: transform 0.25s ease, box-shadow 0.25s ease, border-color 0.25s ease;
    color: #dfe8ff;
    position: relative;
    isolation: isolate;
  }

  .icon-button::before {
    content: "";
    position: absolute;
    inset: 6%;
    border-radius: 50%;
    background: rgba(255, 255, 255, 0.5);
    z-index: -1;
    transition: transform 0.25s ease, box-shadow 0.25s ease;
    box-shadow: 0 0 18px rgba(255, 255, 255, 0.15);
  }

  .icon-button svg {
    width: 60%;
    height: 60%;
    transition: filter 0.25s ease, drop-shadow 0.25s ease;
    position: relative;
    z-index: 1;
  }

  .icon-button:hover,
  .icon-button:focus-visible {
    transform: translateY(-4px) scale(1.05);
    box-shadow: 0 8px 28px rgba(0, 0, 0, 0.6), 0 0 32px rgba(255, 255, 255, 0.4);
    border-color: rgba(255, 255, 255, 0.75);
    outline: none;
  }

  .icon-button:hover::before,
  .icon-button:focus-visible::before {
    transform: scale(1.05);
    box-shadow: 0 0 32px rgba(255, 255, 255, 0.3);
  }

  .icon-button:hover svg,
  .icon-button:focus-visible svg {
    filter: brightness(1.2) saturate(1.1) drop-shadow(0 0 12px rgba(255, 255, 255, 0.5));
  }

  .icon-button.canyoner svg {
    filter: brightness(1.35);
  }

  .icon-button.caver svg {
    filter: brightness(1.1);
  }

  .icon-button.rescue svg {
    filter: brightness(0.9);
  }

  .icon-button.canyoner {
    color: #f5fcff;
  }

  .icon-button.caver {
    color: #e2ecff;
  }

  .icon-button.rescue {
    color: #cad3ff;
  }

  #info-container {
    flex: 1;
    display: flex;
    flex-direction: column;
    height: 100%;
    overflow: hidden;
  }

  #info-panel {
    flex: 1;
    overflow-y: auto;
    padding: 15px;
    background-color: rgba(20, 20, 20, 0.95);
    color: #f0f0f0;
  }

  #image-wrapper {
    flex: 0 0 auto;
    display: flex;
    justify-content: center;
    align-items: center;
    height: 40vh;
  }

  img.preview {
    max-width: 100%;
    max-height: 100%;
    object-fit: contain;
    border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 4px;
    background-color: rgba(0, 0, 0, 0.6);
  }

  #user-panel {
    flex: 0 0 40px;
    padding: 4px 10px;
    border-top: 1px solid rgba(255, 255, 255, 0.2);
    background-color: rgba(15, 15, 15, 0.95);
    display: flex;
    align-items: center;
    justify-content: space-between;
    color: #f0f0f0;
  }

  #user-panel select {
    flex: 1;
    margin-left: 8px;
    font-size: 13px;
    padding: 3px;
    background-color: #111;
    color: #f0f0f0;
    border: 1px solid rgba(255, 255, 255, 0.2);
  }

  /* --- Portrait mode (vertical stacking) --- */
  @media screen and (orientation: portrait) {
    #split-container {
      flex-direction: column !important;
    }

    #graph-div {
      flex: 0 0 40vh;
      border-right: none;
      border-bottom: 1px solid rgba(255, 255, 255, 0.2);
    }

    #info-container {
      flex: 1;
      height: 60vh;
    }

    #info-panel {
      flex: 1;
      overflow-y: auto;
    }

    #image-wrapper {
      height: 25vh;
      max-height: 40%;
    }

    #user-panel {
      flex: 0 0 35px;
      height: 35px;
    }
  }

  /* --- Landscape tablets/phones --- */
  @media screen and (orientation: landscape) {
    #split-container {
      flex-direction: row !important;
    }

    #graph-div {
      flex: 1.4;
      border-bottom: none;
      border-right: 1px solid rgba(255, 255, 255, 0.2);
    }

    #info-container {
      flex: 1;
      flex-direction: column;
    }
  }
</style>

</head>
<body>
  <div id="split-container">
    <div id="graph-div">
      <div id="graph-hotspots" aria-hidden="true">
        <div class="hotspot-column">
          <button class="icon-button canyoner" type="button" aria-label="Canyoning focus">
            <svg viewBox="0 0 64 64" role="img" aria-hidden="true">
              <path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="4" d="M18 20a6 6 0 1 1 12 0 6 6 0 0 1-12 0Zm6 8 8 10m-8-10-8 12m16-2 10 6m-26 4 10-10m18 6-6 12m-22-2h24" />
            </svg>
          </button>
        </div>
        <div class="hotspot-column">
          <button class="icon-button caver" type="button" aria-label="Caving focus">
            <svg viewBox="0 0 64 64" role="img" aria-hidden="true">
              <path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="4" d="M20 24c0-6 6-12 12-12s12 6 12 12v2m0 0 8 6-8 6m-24-12-8 6 8 6m0 0v8l12 8 12-8v-8m-24 0 12 6 12-6" />
            </svg>
          </button>
        </div>
        <div class="hotspot-column">
          <button class="icon-button rescue" type="button" aria-label="Rescue focus">
            <svg viewBox="0 0 64 64" role="img" aria-hidden="true">
              <path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="4" d="M12 42h40l6-12H6l6 12Zm12-18h16m-8 0V8m-8 42h16m-8 0v6" />
            </svg>
          </button>
        </div>
      </div>
    </div>
    <div id="info-container">
      <div id="info-panel">
        <h3>Select a node</h3>
        <div id="info-text"></div>
        <div id="image-wrapper"></div>
      </div>
      <div id="user-panel">
        <b>Show progress for:</b>
        <select id="user-select"><option value="">â€” Select user â€”</option></select>
      </div>
    </div>
  </div>

  <script>
  async function main() {
    const base = "https://thatkow.github.io/nucc-progression-map/";
    const cachebust = "?v=" + new Date().getTime();

    // âœ… Load definition.csv
    const defURL = base + "definition.csv" + cachebust;
    const defResp = await fetch(defURL);
    const defText = await defResp.text();
    console.log("âœ… Loaded definition.csv:", defText);

    const rows = defText.trim().split(/\r?\n/).map(r =>
      r.match(/(".*?"|[^",]+)(?=\s*,|\s*$)/g)?.map(v => v.replace(/^"|"$/g, "")) || []
    );
    const headers = rows.shift();
    const definition = rows.map(row => Object.fromEntries(row.map((v, i) => [headers[i], v])));
    console.log("âœ… Parsed definition data:", definition);

    // âœ… Load user progress CSV
    const csvURL = base + "user_progress.csv" + cachebust;
    const csvResp = await fetch(csvURL);
    const csvText = await csvResp.text();
    console.log("âœ… Loaded user progress CSV:", csvText);

    const csvRows = csvText.trim().split(/\r?\n/).map(r => r.split(","));
    const csvHeaders = csvRows.shift();
    const users = csvRows.map(r => r[0]);
    const userProgress = Object.fromEntries(
      csvRows.map(r => [r[0], Object.fromEntries(csvHeaders.slice(1).map((c, i) => [c, r[i + 1]]))])
    );

    const container = document.getElementById('graph-div');

    const iconCache = {};

    function createGrayscaleDataURL(url) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.crossOrigin = "anonymous";
        img.onload = () => {
          try {
            const canvas = document.createElement("canvas");
            canvas.width = img.width;
            canvas.height = img.height;
            const ctx = canvas.getContext("2d");
            ctx.drawImage(img, 0, 0);
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            for (let i = 0; i < imageData.data.length; i += 4) {
              const r = imageData.data[i];
              const g = imageData.data[i + 1];
              const b = imageData.data[i + 2];
              const gray = Math.round(0.299 * r + 0.587 * g + 0.114 * b);
              imageData.data[i] = gray;
              imageData.data[i + 1] = gray;
              imageData.data[i + 2] = gray;
            }
            ctx.putImageData(imageData, 0, 0);
            resolve(canvas.toDataURL());
          } catch (err) {
            reject(err);
          }
        };
        img.onerror = reject;
        img.src = url;
      });
    }

    async function ensureIcon(nodeId) {
      if (iconCache[nodeId]) return iconCache[nodeId];
      const iconName = encodeURIComponent(nodeId) + ".png";
      const iconURL = base + "icons/" + iconName + cachebust;
      try {
        const grayscale = await createGrayscaleDataURL(iconURL);
        iconCache[nodeId] = { color: iconURL, gray: grayscale };
      } catch (err) {
        console.warn("âš ï¸ Unable to build grayscale icon for", nodeId, err);
        iconCache[nodeId] = { color: iconURL, gray: iconURL };
      }
      return iconCache[nodeId];
    }

    const nodeEntries = await Promise.all(definition.map(async n => {
      const icons = await ensureIcon(n.id);
      return {
        id: n.id,
        title: n.description,
        image: icons.color,
        shape: "image",
        x: Number(n.x),
        y: Number(n.y),
        fixed: { x: true, y: true },
        category: n.category,
        signoff: n.signoff,
        description: n.description
      };
    }));

    const nodes = new vis.DataSet(nodeEntries);

    // ðŸ”— Build edges from prereq column
    const edgesArr = [];
    definition.forEach(n => {
      if (n.prereq && n.prereq.trim() !== "") {
        n.prereq.split(";").forEach(p => {
          const prereq = p.trim();
          if (prereq) edgesArr.push({ from: prereq, to: n.id, arrows: "to" });
        });
      }
    });
    const edges = new vis.DataSet(edgesArr);

    const data = { nodes, edges };

    // âš™ï¸ Network options
    const options = {
      physics: { enabled: false },
      interaction: {
        dragNodes: false,
        dragView: true,
        zoomView: true
      },
      edges: { smooth: false, color: "#333" },
      nodes: { shape: "image", borderWidth: 0, chosen: false }
    };

    const network = new vis.Network(container, data, options);
    let minAllowedScale = null;
    let initialBounds = null;

    function fitNetworkToNodes() {
      const width = container.clientWidth;
      const height = container.clientHeight;
      if (!width || !height || nodeEntries.length === 0) return;

      let minX = Infinity;
      let maxX = -Infinity;
      let minY = Infinity;
      let maxY = -Infinity;

      nodeEntries.forEach(({ x, y }) => {
        if (Number.isFinite(x) && Number.isFinite(y)) {
          if (x < minX) minX = x;
          if (x > maxX) maxX = x;
          if (y < minY) minY = y;
          if (y > maxY) maxY = y;
        }
      });

      if (!Number.isFinite(minX) || !Number.isFinite(maxX) ||
          !Number.isFinite(minY) || !Number.isFinite(maxY)) {
        return;
      }

      const marginRatio = 0.1;
      const spanX = Math.max(maxX - minX, 0);
      const spanY = Math.max(maxY - minY, 0);
      const rangeX = Math.max(spanX, 1);
      const rangeY = Math.max(spanY, 1);
      const usableWidth = Math.max(width * (1 - marginRatio * 2), 1);
      const usableHeight = Math.max(height * (1 - marginRatio * 2), 1);
      const scaleX = usableWidth / rangeX;
      const scaleY = usableHeight / rangeY;
      const scale = Math.max(Math.min(scaleX, scaleY), 0.01);
      const centerX = (minX + maxX) / 2;
      const centerY = (minY + maxY) / 2;

      minAllowedScale = scale;
      const marginX = rangeX * marginRatio;
      const marginY = rangeY * marginRatio;
      initialBounds = {
        minX: minX - marginX,
        maxX: maxX + marginX,
        minY: minY - marginY,
        maxY: maxY + marginY
      };

      network.moveTo({
        position: { x: centerX, y: centerY },
        scale,
        animation: false
      });
      clampView(scale, { x: centerX, y: centerY });
    }

    function clampView(scaleOverride = null, positionOverride = null) {
      if (!initialBounds) return;

      const width = container.clientWidth;
      const height = container.clientHeight;
      if (!width || !height) return;

      const currentScale = scaleOverride ?? network.getScale();
      const currentPosition = positionOverride ?? network.getViewPosition();
      const effectiveScale = minAllowedScale !== null
        ? Math.max(currentScale, minAllowedScale)
        : currentScale;

      const halfWidth = width / (effectiveScale * 2);
      const halfHeight = height / (effectiveScale * 2);

      let minCenterX = initialBounds.minX + halfWidth;
      let maxCenterX = initialBounds.maxX - halfWidth;
      let minCenterY = initialBounds.minY + halfHeight;
      let maxCenterY = initialBounds.maxY - halfHeight;

      if (minCenterX > maxCenterX) {
        const midX = (initialBounds.minX + initialBounds.maxX) / 2;
        minCenterX = maxCenterX = midX;
      }
      if (minCenterY > maxCenterY) {
        const midY = (initialBounds.minY + initialBounds.maxY) / 2;
        minCenterY = maxCenterY = midY;
      }

      const clampedX = Math.min(Math.max(currentPosition.x, minCenterX), maxCenterX);
      const clampedY = Math.min(Math.max(currentPosition.y, minCenterY), maxCenterY);

      const needsMove =
        Math.abs(clampedX - currentPosition.x) > 1e-2 ||
        Math.abs(clampedY - currentPosition.y) > 1e-2 ||
        Math.abs(effectiveScale - currentScale) > 1e-6;

      if (needsMove) {
        network.moveTo({
          position: { x: clampedX, y: clampedY },
          scale: effectiveScale,
          animation: false
        });
      }
    }

    const resizeObserver = typeof ResizeObserver !== "undefined"
      ? new ResizeObserver(() => fitNetworkToNodes())
      : null;
    if (resizeObserver) {
      resizeObserver.observe(container);
    } else {
      window.addEventListener("resize", fitNetworkToNodes);
    }

    const handleAfterDrawing = () => {
      fitNetworkToNodes();
      network.off("afterDrawing", handleAfterDrawing);
    };
    network.on("afterDrawing", handleAfterDrawing);

    network.on("zoom", params => {
      clampView(params.scale);
    });

    network.on("dragEnd", params => {
      if (!params.nodes || params.nodes.length === 0) {
        clampView();
      }
    });

    network.on("animationFinished", () => {
      clampView();
    });

    // ðŸ‘¥ Populate user dropdown
    const select = document.getElementById('user-select');
    users.forEach(u => {
      const opt = document.createElement('option');
      opt.value = u;
      opt.textContent = u;
      select.appendChild(opt);
    });

    // ðŸ‘¤ User progress toggle
    let selectedNodeId = null;

    function iconForNode(id) {
      return iconCache[id] || { color: "", gray: "" };
    }

    function nodeVisualState(nodeId, progressMap) {
      const icons = iconForNode(nodeId);
      const completed = !progressMap ? true : !!progressMap[nodeId];
      return {
        image: completed ? icons.color : icons.gray,
        completed
      };
    }

    function applyNodeStyles(progressMap) {
      nodes.forEach(node => {
        const visual = nodeVisualState(node.id, progressMap);
        const update = {
          id: node.id,
          image: visual.image,
          opacity: visual.completed ? 1 : 0.45
        };
        if (selectedNodeId === node.id) {
          update.shape = "circularImage";
          update.borderWidth = 4;
          update.borderWidthSelected = 4;
          update.color = { border: "#2b7ce9", highlight: { border: "#2b7ce9" } };
        } else {
          update.shape = "image";
          update.borderWidth = 0;
          update.borderWidthSelected = 0;
          update.color = { border: "rgba(0,0,0,0)" };
        }
        nodes.update(update);
      });
    }

    function setSelectedNode(nodeId, progressMap) {
      if (selectedNodeId === nodeId) return;
      const previous = selectedNodeId;
      selectedNodeId = nodeId;
      if (previous) {
        const visual = nodeVisualState(previous, progressMap);
        nodes.update({
          id: previous,
          shape: "image",
          borderWidth: 0,
          borderWidthSelected: 0,
          color: { border: "rgba(0,0,0,0)" },
          image: visual.image,
          opacity: visual.completed ? 1 : 0.45
        });
      }
      if (selectedNodeId) {
        const visual = nodeVisualState(selectedNodeId, progressMap);
        nodes.update({
          id: selectedNodeId,
          shape: "circularImage",
          borderWidth: 4,
          borderWidthSelected: 4,
          color: { border: "#2b7ce9", highlight: { border: "#2b7ce9" } },
          image: visual.image,
          opacity: visual.completed ? 1 : 0.45
        });
      }
    }

    select.addEventListener('change', () => {
      const user = select.value;
      const progress = user ? userProgress[user] || {} : null;
      applyNodeStyles(progress);
    });

    // ðŸ–±ï¸ Node click info & image
    network.on("click", params => {
      if (params.nodes.length) {
        const node = nodes.get(params.nodes[0]);
        const user = select.value;
        const progress = user ? userProgress[user] || {} : null;
        setSelectedNode(node.id, progress);
        const info = document.getElementById('info-text');
        const imagePanel = document.getElementById('image-wrapper');
        info.innerHTML = `
          <h3>${node.id}</h3>
          <b>Category:</b> ${node.category}<br>
          <b>Sign-off:</b> ${node.signoff}<br><br>
          <div style="white-space:pre-line">${node.description}</div>
        `;
        const imgName = encodeURIComponent(node.id.replace(/\s+/g, " ")) + ".png";
        const imgURL = base + "images/" + imgName;
        const testImg = new Image();
        testImg.onload = () => {
          imagePanel.innerHTML = `<img src="${imgURL}" class="preview" alt="${node.id} image">`;
        };
        testImg.onerror = () => {
          imagePanel.innerHTML = "";
        };
        testImg.src = imgURL;
      } else {
        const user = select.value;
        const progress = user ? userProgress[user] || {} : null;
        setSelectedNode(null, progress);
        const info = document.getElementById('info-text');
        const imagePanel = document.getElementById('image-wrapper');
        info.innerHTML = "";
        imagePanel.innerHTML = "";
      }
    });

    // Initialize node appearance
    applyNodeStyles(null);
  }

  main();
  </script>
</body>
</html>

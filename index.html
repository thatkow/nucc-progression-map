<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>NUCC Progression Map</title>
  <script src="https://unpkg.com/vis-network@9.1.6/dist/vis-network.min.js"></script>
  <link href="https://unpkg.com/vis-network@9.1.6/dist/vis-network.min.css" rel="stylesheet" />
  <style>
  /* --- Base layout (desktop & landscape default) --- */
  #split-container {
    display: flex;
    flex-direction: row;
    height: 100vh;
    width: 100%;
  }

  #graph-div {
    flex: 2;
    border-right: 1px solid #ccc;
    overflow: hidden;
  }

  #info-container {
    flex: 1;
    display: flex;
    flex-direction: column;
    height: 100%;
    overflow: hidden;
  }

  #info-panel {
    flex: 1;
    overflow-y: auto;
    padding: 15px;
    background-color: #f9f9f9;
  }

  #image-wrapper {
    flex: 0 0 auto;
    display: flex;
    justify-content: center;
    align-items: center;
    height: 40vh;
  }

  img.preview {
    max-width: 100%;
    max-height: 100%;
    object-fit: contain;
    border: 1px solid #bbb;
    border-radius: 4px;
    background-color: #fff;
  }

  #user-panel {
    flex: 0 0 40px;
    padding: 4px 10px;
    border-top: 1px solid #ccc;
    background-color: #fff;
    display: flex;
    align-items: center;
    justify-content: space-between;
  }

  #user-panel select {
    flex: 1;
    margin-left: 8px;
    font-size: 13px;
    padding: 3px;
  }

  /* --- Portrait mode (vertical stacking) --- */
  @media screen and (orientation: portrait) {
    #split-container {
      flex-direction: column !important;
    }

    #graph-div {
      flex: 0 0 40vh;
      border-right: none;
      border-bottom: 1px solid #ccc;
    }

    #info-container {
      flex: 1;
      height: 60vh;
    }

    #info-panel {
      flex: 1;
      overflow-y: auto;
    }

    #image-wrapper {
      height: 25vh;
      max-height: 40%;
    }

    #user-panel {
      flex: 0 0 35px;
      height: 35px;
    }
  }

  /* --- Landscape tablets/phones --- */
  @media screen and (orientation: landscape) {
    #split-container {
      flex-direction: row !important;
    }

    #graph-div {
      flex: 1.4;
      border-bottom: none;
      border-right: 1px solid #ccc;
    }

    #info-container {
      flex: 1;
      flex-direction: column;
    }
  }
</style>

</head>
<body>
  <div id="split-container">
    <div id="graph-div"></div>
    <div id="info-container">
      <div id="info-panel">
        <h3>Select a node</h3>
        <div id="info-text"></div>
        <div id="image-wrapper"></div>
      </div>
      <div id="user-panel">
        <b>Show progress for:</b>
        <select id="user-select"><option value="">— Select user —</option></select>
      </div>
    </div>
  </div>

  <script>
  async function main() {
    const base = "https://thatkow.github.io/nucc-progression-map/";
    const cachebust = "?v=" + new Date().getTime();

    // ✅ Load definition.csv
    const defURL = base + "definition.csv" + cachebust;
    const defResp = await fetch(defURL);
    const defText = await defResp.text();
    console.log("✅ Loaded definition.csv:", defText);

    const rows = defText.trim().split(/\r?\n/).map(r =>
      r.match(/(".*?"|[^",]+)(?=\s*,|\s*$)/g)?.map(v => v.replace(/^"|"$/g, "")) || []
    );
    const headers = rows.shift();
    const definition = rows.map(row => Object.fromEntries(row.map((v, i) => [headers[i], v])));
    console.log("✅ Parsed definition data:", definition);

    // ✅ Load user progress CSV
    const csvURL = base + "user_progress.csv" + cachebust;
    const csvResp = await fetch(csvURL);
    const csvText = await csvResp.text();
    console.log("✅ Loaded user progress CSV:", csvText);

    const csvRows = csvText.trim().split(/\r?\n/).map(r => r.split(","));
    const csvHeaders = csvRows.shift();
    const users = csvRows.map(r => r[0]);
    const userProgress = Object.fromEntries(
      csvRows.map(r => [r[0], Object.fromEntries(csvHeaders.slice(1).map((c, i) => [c, r[i + 1]]))])
    );

    const container = document.getElementById('graph-div');

    const iconCache = {};

    function createGrayscaleDataURL(url) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.crossOrigin = "anonymous";
        img.onload = () => {
          try {
            const canvas = document.createElement("canvas");
            canvas.width = img.width;
            canvas.height = img.height;
            const ctx = canvas.getContext("2d");
            ctx.drawImage(img, 0, 0);
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            for (let i = 0; i < imageData.data.length; i += 4) {
              const r = imageData.data[i];
              const g = imageData.data[i + 1];
              const b = imageData.data[i + 2];
              const gray = Math.round(0.299 * r + 0.587 * g + 0.114 * b);
              imageData.data[i] = gray;
              imageData.data[i + 1] = gray;
              imageData.data[i + 2] = gray;
            }
            ctx.putImageData(imageData, 0, 0);
            resolve(canvas.toDataURL());
          } catch (err) {
            reject(err);
          }
        };
        img.onerror = reject;
        img.src = url;
      });
    }

    async function ensureIcon(nodeId) {
      if (iconCache[nodeId]) return iconCache[nodeId];
      const iconName = encodeURIComponent(nodeId) + ".png";
      const iconURL = base + "icons/" + iconName + cachebust;
      try {
        const grayscale = await createGrayscaleDataURL(iconURL);
        iconCache[nodeId] = { color: iconURL, gray: grayscale };
      } catch (err) {
        console.warn("⚠️ Unable to build grayscale icon for", nodeId, err);
        iconCache[nodeId] = { color: iconURL, gray: iconURL };
      }
      return iconCache[nodeId];
    }

    const nodeEntries = await Promise.all(definition.map(async n => {
      const icons = await ensureIcon(n.id);
      return {
        id: n.id,
        title: n.description,
        image: icons.color,
        shape: "image",
        x: Number(n.x),
        y: Number(n.y),
        fixed: { x: true, y: true },
        category: n.category,
        signoff: n.signoff,
        description: n.description
      };
    }));

    const nodes = new vis.DataSet(nodeEntries);

    // 🔗 Build edges from prereq column
    const edgesArr = [];
    definition.forEach(n => {
      if (n.prereq && n.prereq.trim() !== "") {
        n.prereq.split(";").forEach(p => {
          const prereq = p.trim();
          if (prereq) edgesArr.push({ from: prereq, to: n.id, arrows: "to" });
        });
      }
    });
    const edges = new vis.DataSet(edgesArr);

    const data = { nodes, edges };

    // ⚙️ Network options
    const options = {
      physics: { enabled: false },
      interaction: {
        dragNodes: false,
        dragView: true,
        zoomView: true
      },
      edges: { smooth: false, color: "#333" },
      nodes: { shape: "image", borderWidth: 0, chosen: false }
    };

    const network = new vis.Network(container, data, options);

    function fitNetworkToNodes() {
      const width = container.clientWidth;
      const height = container.clientHeight;
      if (!width || !height || nodeEntries.length === 0) return;

      let minX = Infinity;
      let maxX = -Infinity;
      let minY = Infinity;
      let maxY = -Infinity;

      nodeEntries.forEach(({ x, y }) => {
        if (Number.isFinite(x) && Number.isFinite(y)) {
          if (x < minX) minX = x;
          if (x > maxX) maxX = x;
          if (y < minY) minY = y;
          if (y > maxY) maxY = y;
        }
      });

      if (!Number.isFinite(minX) || !Number.isFinite(maxX) ||
          !Number.isFinite(minY) || !Number.isFinite(maxY)) {
        return;
      }

      const marginRatio = 0.1;
      const rangeX = Math.max(maxX - minX, 1);
      const rangeY = Math.max(maxY - minY, 1);
      const usableWidth = Math.max(width * (1 - marginRatio * 2), 1);
      const usableHeight = Math.max(height * (1 - marginRatio * 2), 1);
      const scaleX = usableWidth / rangeX;
      const scaleY = usableHeight / rangeY;
      const scale = Math.max(Math.min(scaleX, scaleY), 0.01);
      const centerX = (minX + maxX) / 2;
      const centerY = (minY + maxY) / 2;

      network.moveTo({
        position: { x: centerX, y: centerY },
        scale,
        animation: false
      });
    }

    const resizeObserver = typeof ResizeObserver !== "undefined"
      ? new ResizeObserver(() => fitNetworkToNodes())
      : null;
    if (resizeObserver) {
      resizeObserver.observe(container);
    } else {
      window.addEventListener("resize", fitNetworkToNodes);
    }

    const handleAfterDrawing = () => {
      fitNetworkToNodes();
      network.off("afterDrawing", handleAfterDrawing);
    };
    network.on("afterDrawing", handleAfterDrawing);

    // 👥 Populate user dropdown
    const select = document.getElementById('user-select');
    users.forEach(u => {
      const opt = document.createElement('option');
      opt.value = u;
      opt.textContent = u;
      select.appendChild(opt);
    });

    // 👤 User progress toggle
    let selectedNodeId = null;

    function iconForNode(id) {
      return iconCache[id] || { color: "", gray: "" };
    }

    function nodeVisualState(nodeId, progressMap) {
      const icons = iconForNode(nodeId);
      const completed = !progressMap ? true : !!progressMap[nodeId];
      return {
        image: completed ? icons.color : icons.gray,
        completed
      };
    }

    function applyNodeStyles(progressMap) {
      nodes.forEach(node => {
        const visual = nodeVisualState(node.id, progressMap);
        const update = {
          id: node.id,
          image: visual.image,
          opacity: visual.completed ? 1 : 0.45
        };
        if (selectedNodeId === node.id) {
          update.shape = "circularImage";
          update.borderWidth = 4;
          update.borderWidthSelected = 4;
          update.color = { border: "#2b7ce9", highlight: { border: "#2b7ce9" } };
        } else {
          update.shape = "image";
          update.borderWidth = 0;
          update.borderWidthSelected = 0;
          update.color = { border: "rgba(0,0,0,0)" };
        }
        nodes.update(update);
      });
    }

    function setSelectedNode(nodeId, progressMap) {
      if (selectedNodeId === nodeId) return;
      const previous = selectedNodeId;
      selectedNodeId = nodeId;
      if (previous) {
        const visual = nodeVisualState(previous, progressMap);
        nodes.update({
          id: previous,
          shape: "image",
          borderWidth: 0,
          borderWidthSelected: 0,
          color: { border: "rgba(0,0,0,0)" },
          image: visual.image,
          opacity: visual.completed ? 1 : 0.45
        });
      }
      if (selectedNodeId) {
        const visual = nodeVisualState(selectedNodeId, progressMap);
        nodes.update({
          id: selectedNodeId,
          shape: "circularImage",
          borderWidth: 4,
          borderWidthSelected: 4,
          color: { border: "#2b7ce9", highlight: { border: "#2b7ce9" } },
          image: visual.image,
          opacity: visual.completed ? 1 : 0.45
        });
      }
    }

    select.addEventListener('change', () => {
      const user = select.value;
      const progress = user ? userProgress[user] || {} : null;
      applyNodeStyles(progress);
    });

    // 🖱️ Node click info & image
    network.on("click", params => {
      if (params.nodes.length) {
        const node = nodes.get(params.nodes[0]);
        const user = select.value;
        const progress = user ? userProgress[user] || {} : null;
        setSelectedNode(node.id, progress);
        const info = document.getElementById('info-text');
        const imagePanel = document.getElementById('image-wrapper');
        info.innerHTML = `
          <h3>${node.id}</h3>
          <b>Category:</b> ${node.category}<br>
          <b>Sign-off:</b> ${node.signoff}<br><br>
          <div style="white-space:pre-line">${node.description}</div>
        `;
        const imgName = encodeURIComponent(node.id.replace(/\s+/g, " ")) + ".png";
        const imgURL = base + "images/" + imgName;
        const testImg = new Image();
        testImg.onload = () => {
          imagePanel.innerHTML = `<img src="${imgURL}" class="preview" alt="${node.id} image">`;
        };
        testImg.onerror = () => {
          imagePanel.innerHTML = "";
        };
        testImg.src = imgURL;
      } else {
        const user = select.value;
        const progress = user ? userProgress[user] || {} : null;
        setSelectedNode(null, progress);
        const info = document.getElementById('info-text');
        const imagePanel = document.getElementById('image-wrapper');
        info.innerHTML = "";
        imagePanel.innerHTML = "";
      }
    });

    // Initialize node appearance
    applyNodeStyles(null);
  }

  main();
  </script>
</body>
</html>
